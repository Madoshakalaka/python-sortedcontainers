from .sortedlist import SortedList as SortedList, recursive_repr as recursive_repr
from typing import MutableSet, Sequence, TypeVar, Callable, Generic, Iterable, Tuple, Iterator
from typing import Any, Optional

_T_co = TypeVar('_T_co')
class SortedSet(MutableSet[_T_co], Sequence[_T_co], Generic[_T_co]):
    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...
    def issubset(self, s: Iterable[_T_co]) -> bool: ...
    def issuperset(self, s: Iterable[_T_co]) -> bool: ...
    def bisect_left(self, value) -> int: ...
    def bisect(self, value) -> int: ...
    def bisect_right(self, value) -> int: ...
    def index(self, value: Any, start: int=..., stop: int=...) -> int: ...
    def irange(self, minimum=..., maximum=..., inclusive: Tuple[bool, bool]=..., reverse: bool=...) -> Any: ...
    def islice(self, start: int=..., stop: int=..., reverse: bool=...) -> Iterable[_T_co]: ...
    def bisect_key_left(self, key: Any) -> int: ...
    def bisect_key_right(self, key: Any) -> int: ...
    def bisect_key(self, key: Any) -> int: ...
    def irange_key(self, min_key= ..., max_key = ..., inclusive: Tuple[bool, bool] = (True, True), reverse: bool = False): ...
    def __init__(self, iterable: Iterable[_T_co] = None, key: Callable[[_T_co], Any] = None) -> None: ...
    @property
    def key(self) -> Optional[Callable[[_T_co], Any]]: ...
    def __contains__(self, value: Any) -> bool: ...
    # fixme: weird "signature incompatible with Supertype 'Sequence'" warning from mypy
    def __getitem__(self, index: int) -> _T_co: ... # type: ignore
    def __delitem__(self, index: int) -> None: ...
    def __eq__(self, other: Any)->bool: ...
    def __ne__(self, other: Any)->bool: ...
    def __lt__(self, other: Any)->bool: ...
    def __gt__(self, other: Any)->bool: ...
    def __le__(self, other: Any)->bool: ...
    def __ge__(self, other: Any)->bool: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T_co]: ...
    def __reversed__(self) -> Iterator[_T_co]: ...
    def add(self, value: Any) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> SortedSet[_T_co]: ...
    def __copy__(self) -> SortedSet[_T_co]: ...
    def count(self, value: Any): ...
    def discard(self, value: Any) -> None: ...
    def pop(self, index: int = ...) -> _T_co: ...
    def remove(self, value: Any) -> None: ...
    # note: not necessarily Iterable[_T_co]
    def difference(self, *iterables: Iterable)->SortedSet[_T_co]: ...
    def __sub__(self, *iterables: Iterable)->SortedSet[_T_co]: ...
    def difference_update(self, *iterables: Iterable)->SortedSet[_T_co]: ...
    def __isub__(self, *iterables: Iterable)->SortedSet[_T_co]: ...
    # note: not necessarily SortedSet[_T_co]
    def intersection(self, *iterables: Iterable)->SortedSet: ...
    def __and__(self, *iterables: Iterable)->SortedSet: ...
    def __rand__(self, *iterables: Iterable)->SortedSet: ...
    def intersection_update(self, *iterables: Iterable)->SortedSet: ...
    def __iand__(self, *iterables: Iterable)->SortedSet: ...
    def symmetric_difference(self, other: Iterable)->SortedSet: ...
    def __xor__(self, other: Iterable)->SortedSet: ...
    def __rxor__(self, other: Iterable)->SortedSet: ...
    def symmetric_difference_update(self, other: Iterable)->SortedSet: ...
    def __ixor__(self, other: Iterable)->SortedSet: ...
    def union(self, *iterables: Iterable)->SortedSet: ...
    def __or__(self, *iterables: Iterable)->SortedSet: ...
    def __ror__(self, *iterables: Iterable)->SortedSet: ...
    def update(self, *iterables: Iterable)->SortedSet: ...
    def __ior__(self, *iterables: Iterable)->SortedSet: ...
    def __reduce__(self): ...
